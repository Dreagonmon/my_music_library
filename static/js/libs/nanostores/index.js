let tasks=0;let resolves=[];function startTask(){tasks+=1;return()=>{tasks-=1;if(tasks===0){let prevResolves=resolves;resolves=[];for(let i of prevResolves)i();}};}function task(cb){let endTask=startTask();let promise=cb().finally(endTask);promise.t=true;return promise;}function allTasks(){if(tasks===0){return Promise.resolve();}else{return new Promise(resolve=>{resolves.push(resolve);});}}function cleanTasks(){tasks=0;}let clean=Symbol("clean");let cleanStores=(...stores)=>{if(""==="production"){throw new Error("cleanStores() can be used only during development or tests");}cleanTasks();for(let $store of stores){if($store){if($store.mocked)delete $store.mocked;if($store[clean])$store[clean]();}}};let listenerQueue=[];let atom=(initialValue,level)=>{let listeners=[];let $atom={get(){if(!$atom.lc){$atom.listen(()=>{})();}return $atom.value;},l:level||0,lc:0,listen(listener,listenerLevel){$atom.lc=listeners.push(listener,listenerLevel||$atom.l)/2;return()=>{let index=listeners.indexOf(listener);if(~index){listeners.splice(index,2);if(!--$atom.lc)$atom.off();}};},notify(oldValue,changedKey){let runListenerQueue=!listenerQueue.length;for(let i=0;i<listeners.length;i+=2){listenerQueue.push(listeners[i],listeners[i+1],$atom.value,oldValue,changedKey);}if(runListenerQueue){for(let i=0;i<listenerQueue.length;i+=5){let skip;for(let j=i+1;!skip&&(j+=5)<listenerQueue.length;){if(listenerQueue[j]<listenerQueue[i+1]){skip=listenerQueue.push(listenerQueue[i],listenerQueue[i+1],listenerQueue[i+2],listenerQueue[i+3],listenerQueue[i+4]);}}if(!skip){listenerQueue[i](listenerQueue[i+2],listenerQueue[i+3],listenerQueue[i+4]);}}listenerQueue.length=0;}},off(){},set(newValue){let oldValue=$atom.value;if(oldValue!==newValue){$atom.value=newValue;$atom.notify(oldValue);}},subscribe(listener,listenerLevel){let unbind=$atom.listen(listener,listenerLevel);listener($atom.value);return unbind;},value:initialValue};if(""!=="production"){$atom[clean]=()=>{listeners=[];$atom.lc=0;$atom.off();};}return $atom;};const UNMOUNT=6;const REVERT_MUTATION=10;let on=(object,listener,eventKey,mutateStore)=>{object.events=object.events||{};if(!object.events[eventKey+10]){object.events[eventKey+REVERT_MUTATION]=mutateStore(eventProps=>{object.events[eventKey].reduceRight((event,l)=>(l(event),event),{shared:{},...eventProps});});}object.events[eventKey]=object.events[eventKey]||[];object.events[eventKey].push(listener);return()=>{let currentListeners=object.events[eventKey];let index=currentListeners.indexOf(listener);currentListeners.splice(index,1);if(!currentListeners.length){delete object.events[eventKey];object.events[eventKey+10]();delete object.events[eventKey+10];}};};let onStart=($store,listener)=>on($store,listener,0,runListeners=>{let originListen=$store.listen;$store.listen=arg=>{if(!$store.lc&&!$store.starting){$store.starting=true;runListeners();delete $store.starting;}return originListen(arg);};return()=>{$store.listen=originListen;};});let onStop=($store,listener)=>on($store,listener,1,runListeners=>{let originOff=$store.off;$store.off=()=>{runListeners();originOff();};return()=>{$store.off=originOff;};});let onSet=($store,listener)=>on($store,listener,2,runListeners=>{let originSet=$store.set;let originSetKey=$store.setKey;if($store.setKey){$store.setKey=(changed,changedValue)=>{let isAborted;let abort=()=>{isAborted=true;};runListeners({abort,changed,newValue:{...$store.value,[changed]:changedValue}});if(!isAborted)return originSetKey(changed,changedValue);};}$store.set=newValue=>{let isAborted;let abort=()=>{isAborted=true;};runListeners({abort,newValue});if(!isAborted)return originSet(newValue);};return()=>{$store.set=originSet;$store.setKey=originSetKey;};});let onNotify=($store,listener)=>on($store,listener,3,runListeners=>{let originNotify=$store.notify;$store.notify=(oldValue,changed)=>{let isAborted;let abort=()=>{isAborted=true;};runListeners({abort,changed,oldValue});if(!isAborted)return originNotify(oldValue,changed);};return()=>{$store.notify=originNotify;};});let STORE_UNMOUNT_DELAY=1e3;let onMount=($store,initialize)=>{let listener=payload=>{let destroy=initialize(payload);if(destroy)$store.events[6].push(destroy);};return on($store,listener,5,runListeners=>{let originListen=$store.listen;$store.listen=(...args)=>{if(!$store.lc&&!$store.active){$store.active=true;runListeners();}return originListen(...args);};let originOff=$store.off;$store.events[UNMOUNT]=[];$store.off=()=>{originOff();setTimeout(()=>{if($store.active&&!$store.lc){$store.active=false;for(let destroy of $store.events[UNMOUNT])destroy();$store.events[UNMOUNT]=[];}},STORE_UNMOUNT_DELAY);};if(""!=="production"){let originClean=$store[clean];$store[clean]=()=>{for(let destroy of $store.events[UNMOUNT])destroy();$store.events[UNMOUNT]=[];$store.active=false;originClean();};}return()=>{$store.listen=originListen;$store.off=originOff;};});};let computedStore=(stores,cb,batched)=>{if(!Array.isArray(stores))stores=[stores];let previousArgs;let currentRunId=0;let set=()=>{let args=stores.map($store=>$store.get());if(previousArgs===undefined||args.some((arg,i)=>arg!==previousArgs[i])){let runId=++currentRunId;previousArgs=args;let value=cb(...args);if(value&&value.then&&value.t){value.then(asyncValue=>{if(runId===currentRunId){$computed.set(asyncValue);}});}else{$computed.set(value);}}};let $computed=atom(undefined,Math.max(...stores.map($s=>$s.l))+1);let timer;let run=batched?()=>{clearTimeout(timer);timer=setTimeout(set);}:set;onMount($computed,()=>{let unbinds=stores.map($store=>$store.listen(run,-1/$computed.l));set();return()=>{for(let unbind of unbinds)unbind();};});return $computed;};let computed=(stores,fn)=>computedStore(stores,fn);let batched=(stores,fn)=>computedStore(stores,fn,true);function getPath(obj,path){let allKeys=getAllKeysFromPath(path);let res=obj;for(let key of allKeys){if(res===undefined){break;}res=res[key];}return res;}function setPath(obj,path,value){return setByKey(obj!=null?obj:{},getAllKeysFromPath(path),value);}function setByKey(obj,splittedKeys,value){let key=splittedKeys[0];ensureKey(obj,key,splittedKeys[1]);let copy=Array.isArray(obj)?[...obj]:{...obj};if(splittedKeys.length===1){if(value===undefined){if(Array.isArray(obj)){copy.splice(key,1);}else{delete copy[key];}}else{copy[key]=value;}return copy;}let newVal=setByKey(obj[key],splittedKeys.slice(1),value);obj[key]=newVal;return obj;}const ARRAY_INDEX=/(.*)\[(\d+)\]/;function getAllKeysFromPath(path){return path.split(".").flatMap(key=>getKeyAndIndicesFromKey(key));}function getKeyAndIndicesFromKey(key){if(ARRAY_INDEX.test(key)){let[,keyPart,index]=key.match(ARRAY_INDEX);return[...getKeyAndIndicesFromKey(keyPart),index];}return[key];}const IS_NUMBER=/^\d+$/;function ensureKey(obj,key,nextKey){if(key in obj){return;}let isNum=IS_NUMBER.test(nextKey);if(isNum){obj[key]=Array(parseInt(nextKey,10)+1).fill(undefined);}else{obj[key]={};}}function deepMap(initial={}){let $deepMap=atom(initial);$deepMap.setKey=(key,value)=>{let oldValue;try{oldValue=structuredClone($deepMap.value);}catch{oldValue={...$deepMap.value};}if(getPath($deepMap.value,key)!==value){$deepMap.value={...setPath($deepMap.value,key,value)};$deepMap.notify(oldValue,key);}};return $deepMap;}let keepMount=$store=>{$store.listen(()=>{});};function listenKeys($store,keys,listener){let keysSet=new Set([...keys,undefined]);return $store.listen((value,oldValue,changed)=>{if(keysSet.has(changed)){listener(value,oldValue,changed);}});}let map=(initial={})=>{let $map=atom(initial);$map.setKey=function(key,value){let oldMap=$map.value;if(typeof value==="undefined"&&key in $map.value){$map.value={...$map.value};delete $map.value[key];$map.notify(oldMap,key);}else if($map.value[key]!==value){$map.value={...$map.value,[key]:value};$map.notify(oldMap,key);}};return $map;};function mapCreator(init){let Creator=(id,...args)=>{if(!Creator.cache[id]){Creator.cache[id]=Creator.build(id,...args);}return Creator.cache[id];};Creator.build=(id,...args)=>{let store=map({id});onMount(store,()=>{let destroy;if(init)destroy=init(store,id,...args);return()=>{delete Creator.cache[id];if(destroy)destroy();};});return store;};Creator.cache={};if(""!=="production"){Creator[clean]=()=>{for(let id in Creator.cache){Creator.cache[id][clean]();}Creator.cache={};};}return Creator;}export{atom as atom};export{clean as clean,cleanStores as cleanStores};export{batched as batched,computed as computed};export{deepMap as deepMap,getPath as getPath,setPath as setPath};export{keepMount as keepMount};export{onMount as onMount,onNotify as onNotify,onSet as onSet,onStart as onStart,onStop as onStop,STORE_UNMOUNT_DELAY as STORE_UNMOUNT_DELAY};export{listenKeys as listenKeys};export{mapCreator as mapCreator};export{map as map};export{allTasks as allTasks,cleanTasks as cleanTasks,startTask as startTask,task as task};